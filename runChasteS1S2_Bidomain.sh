#!/bin/bash


#Siqi Wei
#June 2022
#Modified for Chaste 2019 release 
#Script to test the S1-S2 protocol using Chaste, cell model: Gray-Pathmanathan Model


#Save the current directory location
startingDir=`pwd`

#Current file: 
currentFilename=runChasteS1S2_Bidomain.sh

#Set Chaste location
CHASTE_LOCATION=/code/Chaste
CHASTE_BUILD=/code/chaste_build

# copy GrayPathmanathan2016Rabbit files to desired direcotry
cp -u GrayPathmanathan2016Rabbit.* $CHASTE_LOCATION/heart/src/odes/ionicmodels

#Set the number of cores used for running tests:
numOfCore=1

#Set the location of the testing file (this needs to be a project in Chaste)
FILE_LOCATION=projects/chaste/test

#Set the folder location for the solution data output generated by the script (doesn't need to be changed)
export CHASTE_TEST_OUTPUT=$CHASTE_LOCATION/projects/chaste/testoutput

#OS method 
OSmethod=Semi_Implicit


#Set the name of the C++ file to be generated
fileName=TestChasteS1S2Bidomain_${OSmethod}
fileNameCplusplus=$fileName.hpp
#Set the name of the results file displaying digits matched
fileResults=Results_runChasteS1S2_Bidomain.txt

#Maximum number of digits that are displayed in the results file
numDigits=20

#Number of time steps (we are outputting the solution every 0.1 ms)
numTimeSteps=1

#These values are all set in the auto-generated C++ file
                        
#The timesteps we want to test (currently PDE and ODE timesteps are the same)
# Could make multiple runs with different time, eg: dtTissue="0.1 0.2"
dtTissue="0.1"
dtCell="0.001"

#The mesh sizes we want to test (must be n*countRef-1 in size, for n a non-negative integer)
mesh="161" # 321 641 1281" # 321 = 0.0125mm  , 641 = 0.00625mm, 161 = 0.025mm, 1281 = 0.003125mm

#Duration in time of the simulation
timeDuration=7.0 #ms

#Bidomain Model parameters:
#Stimulus 
stimulusCurrent="-214500" # 34 # -180000 -210000 -217500 -270000 -300000 -450000 #  120 140 145 180 200 300 #    =152 uA/uF #in uA/cm^3 # uA/cm^3 = uA/uF * Cm uF/cm^3 * Chi 1/cm   for positive stimulus, use istim = -**
stimulusDuration=2.0 #2.0 #0.5  #2.0       #ms
stimulusStarttime=0.0   #5.0
stimulusRange_x=0.05 #0.05 #0.05 # 0.05  #cm Nied: 0.15
stimulusRange_y=0.01 #0.01 #0.01  #cm Nied: 0.15
stimulusRange_z=0.0025  #cm Nied: 0.15
electrodeposition_x=0.1333 #0.1333 #0.1333  #0.1333 Nied: 0.0
electrodeposition_y=0.020833 #0.020833 #0.020833  # 0.020833 Nied: 0.0
electrodeposition_z=0.0 #Nied: 0.0



#Conductivities ms/cm
sigma_ix=2.525 #0.002525 #1.3342  #2.0
sigma_iy=0.222 #0.000222 #0.1761  #0.2
sigma_iz=0.222 #0.000222 #0.1761  #0.2
sigma_ex=8.21 #0.00821 #0  #8.0
sigma_ey=2.15 #0.00215 #0   #2.0
sigma_ez=2.15 #0.00215 #0   #2.0

#Cm, Chi
Cm=1  #nuF/cm^2
Chi=1500  #1/cm

#Domain of the 3D problem
xLength=0.4 #cm Nied : 2.0
yLength=0.0625  #cm  Nied: 0.3
zLength=0.0025  #cm Nied: 0.7

#Cell model name and constructor name
#For some of the cell models available in Chaste, see heart/build/debug/src/odes/cellml or heart/src/odes/ionicmodels
cellModel=Gray2016  #Gray2016 #TenTusscher2006Epi  #LuoRudy1991
cellModelfileName=GrayPathmanathan2016Rabbit  #LuoRudy1991  #TenTusscher2006Epi #GrayPathmanathan2016Rabbit
cellModelConstructor=GrayPathmanathan2016Rabbit #CellLuoRudy1991FromCellML  #CellTenTusscher2006EpiFromCellML  #
                        
#ODE solver method                        
#For some of the ODE methods available in Chaste, see odes/src/solver                        
odeSolver=EulerIvpOdeSolver #RungeKutta2IvpOdeSolver                        



for ODEtimeStep in $dtCell  #For each timestep listed in dt
do
	echo "$ODEtimeStep"

	for PDEtimeStep in $dtTissue
	do
		echo "PDEtimeStep"
		for meshSize in `echo $mesh` #For each of the meshes listed
		do
			for stimcurrent in $stimulusCurrent
			do			
			
			#Move to the starting directory
			cd $startingDir


			# These values are all set in the auto-generated C++ file
		    # ODE and PDE timesteps
			timeStepODE=$ODEtimeStep
			timeStepPDE=$PDEtimeStep

			output_dir=Bidomain_3D_Feb15_${stimcurrent}_${meshSize}

			#Save all of the values being used in the results file
			echo -e "
			Results auto-generated from $currentFilename
			ODE timestep = $timeStepODE
			PDE timestep = $timeStepPDE
			Simulation duration = $timeDuration
			3D interval = [0, $xLength]x[0, $yLength]x[0,$zLength]
			Cell model = $cellModelConstructor
			ODE method = $odeSolver 
			Number of mesh points = $meshSize

			Results:
			" >>$CHASTE_TEST_OUTPUT/$fileResults

			#Move to the Chaste folder
			cd $CHASTE_LOCATION

			#Generate the C++ file
			##################################
			/bin/echo -e "
			/*
			Copyright (c) 2005-2019, University of Oxford.
			All rights reserved.

			University of Oxford means the Chancellor, Masters and Scholars of the
			University of Oxford, having an administrative office at Wellington
			Square, Oxford OX1 2JD, UK.

			This file is part of Chaste.

			Redistribution and use in source and binary forms, with or without
			modification, are permitted provided that the following conditions are met:
			 * Redistributions of source code must retain the above copyright notice,
			this list of conditions and the following disclaimer.
			 * Redistributions in binary form must reproduce the above copyright notice,
			this list of conditions and the following disclaimer in the documentation
			and/or other materials provided with the distribution.
			 * Neither the name of the University of Oxford nor the names of its
			contributors may be used to endorse or promote products derived from this
			software without specific prior written permission.

			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"
			AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
			IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
			ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
			LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
			CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
			GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
			HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
			LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
			OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

			*/

			/*
			 *  Use this code to test S1-S2 protocal 
			 *
			 */
			#ifndef TESTCHASTES1S2BIDOMAIN_HPP_
			#define TESTCHASTES1S2BIDOMAIN_HPP_

			/*
			 * HOW_TO_TAG Cardiac/Problem definition
			 * Set up and run basic bidomain simulations
			 */

			/*
			 * = An example showing how to run bidomain simulations =
			 *
			 * == Introduction ==
			 *
			 * In this tutorial we show how Chaste is used to run a standard bidomain simulation.
			 * Note that monodomain simulations are run very similarly.
			 *
			 * The first thing that needs to be done, when writing any Chaste test,
			 * is to include the following header.
			 */

			#include <cxxtest/TestSuite.h>
 			#include <boost/archive/text_oarchive.hpp>
                        #include <boost/archive/text_iarchive.hpp>
                        #include <vector>
                        #include <cmath>
						#include \"CellMLToSharedLibraryConverter.hpp\"
						#include \"DynamicCellModelLoader.hpp\"
						#include \"LuoRudy1991.hpp\"
						#include \"AbstractCardiacCell.hpp\"
                        #include \"AbstractCardiacCellFactory.hpp\"
			#include \"BidomainProblem.hpp\"
			#include \"SimpleStimulus.hpp\"
			#include \"PetscSetupAndFinalize.hpp\"
			#include \"$cellModelfileName.hpp\"
			#include \"$odeSolver.hpp\"
			#include \"ZeroStimulusCellFactory.hpp\"
			#include \"TetrahedralMesh.hpp\"
			#include \"PetscTools.hpp\"
			

                        //template<unsigned DIM>
			class PointStimulus3dCellFactory : public AbstractCardiacCellFactory<3>
			{
			
			  /*Define the stimulus */
                          /* Simple Stimulus */
			  private:
			        boost::shared_ptr<SimpleStimulus> mpStimulus;
						
			public:
				PointStimulus3dCellFactory()
				: AbstractCardiacCellFactory<3>(),
				mpStimulus(new SimpleStimulus(${stimcurrent}, ${stimulusDuration},${stimulusStarttime}))
				{ 
				}
						
		
				AbstractCardiacCell* CreateCardiacCellForTissueNode(Node<3>* pNode)
				{
					double x = pNode->rGetLocation()[0];
					double y = pNode->rGetLocation()[1];
					double z = pNode->rGetLocation()[2];
									//std::cout<< \"set up cardiac cell  \" << std::endl;
					boost::shared_ptr<${odeSolver}> p_solver(new ${odeSolver}());

					//FileFinder cellml_file(\"heart/src/odes/cellml/LuoRudy1991.cellml\", RelativeTo::ChasteSourceRoot);
					//OutputFileHandler handler(\"converted_file_folder\", true);
					//FileFinder copied_file = handler.CopyFileTo(cellml_file);
					//CellMLToSharedLibraryConverter converter(true);
					//converter.SetOptions({\"--normal\"});
					//DynamicCellModelLoaderPtr p_loader = converter.Convert(copied_file);
				


					//if (((0.13333+(0.0025/2))<=x) && (x<=(0.18333-(0.0025/2))) && (0.02083+(0.0025/2))<=y)&&(y<=(0.03083-(0.0025/2)))&&(0.0<=z)&&(z<=0.0025))
					//if (((0.13333+(0.0025/2))<x) && (x<(0.18333-(0.0025/2))) && ((0.02083+(0.0025/2))<y)&&(y<(0.03083-(0.0025/2)))&&(0.0<=z)&&(z<=0.0025))
					if (($electrodeposition_x<=x) && (x<=$electrodeposition_x+$stimulusRange_x) && ($electrodeposition_y<=y)&&(y<=$electrodeposition_y+$stimulusRange_y) && ($electrodeposition_z<=z)&&(z<=$electrodeposition_z+$stimulusRange_z))
						//(x<$stimulusRange_x+1e-6) && (y<$stimulusRange_y+1e-6) && (z<$stimulusRange_z+1e-6)) // ie if x<=0.05cm and y<=0.01cm (and we are assuming here x,y>=0).
					{
						/* Create a LR91 cell with the non-zero stimulus. This is a volume stimulus, ie
						* the function on the right-hand side of the first of the two bidomain equations.
						* An equal and opposite extra-cellular stimulus is implicitly enforced by the code,
						* which corresponds to having zero on the right-hand side of the second of the
						* bidomain equations.
						*/

						//std::ofstream outputFile("outStimDofs.txt",append);

						return new $cellModelConstructor(p_solver, mpStimulus);
						//return new (p_loader->CreateCell(p_solver, mpStimulus));
						//return dynamic_cast<AbstractCardiacCell*>(p_loader->CreateCell(p_solver, mpStimulus));
						//std::cout << \"Hi\" << std::endl;
						//std::cout << \"Stim Point: \" << x << \",\" << y << \",\" << z << std::endl;
						
					}
					else
					{
						//std::ofstream outputFile("outStimDofs.txt",append);
						/* The other cells have zero stimuli. */
						//return new dynamic_cast<AbstractCardiacCell*>(p_loader->CreateCell(p_solver, mpZeroStimulus));
						return new $cellModelConstructor(p_solver, mpZeroStimulus);
						//return new (p_loader->CreateCell(p_solver, mpZeroStimulus));
						//std::cout << \"Zero: \" << x << \",\" << y << \",\" << z << std::endl;
						// std::cout<<\"setup stimulus \" << std::endl;
					}
					//HeartConfig::Instance()->SetOutputVariables( $cellModelConstructor.rGetStateVariableNames() );
					//unsigned node_index = pNode->GetIndex();
					//if (node_index==1505)
					//{	
					//	std::cout << \" IStim = \" << p_cell->GetAnyVariable("i_stim") << std::endl;

					//}

				
				}
				//FileFinder cellml_file(\"heart/src/odes/cellml/LuoRudy1991.cellml\", RelativeTo::ChasteSourceRoot);
				//OutputFileHandler handler(\"converted_file_folder\", true);
				//FileFinder copied_file = handler.CopyFileTo(cellml_file);
				//CellMLToSharedLibraryConverter converter(true);
				//converter.SetOptions({\"--normal\"});
				//DynamicCellModelLoaderPtr p_loader = converter.Convert(copied_file);
				//CreateCardiacCellForTissueNode(Node<3>* pNode) = dynamic_cast<AbstractCardiacCell*>(p_loader->CreateCell(p_solver,mpStimulus));

				/* We have no need for a destructor, since the problem class deals with deleting the cells. */
			};

			/*
			* == Running the bidomain simulation ==
			*
			* Now we can define the test class, which must inherit from {{{CxxTest::TestSuite}}}
			* as described in the writing basic tests tutorial. */
			class TestChasteS1S2Bidomain : public CxxTest::TestSuite
			{
			
			public:
				//std::vector<std::string> output_variables;
				void TestSimpleSimulation()
				{
				std::cout<< \"Here1  \" << std::endl;
				/* Define the mesh, unit of length:  cm
				*/
				double xLength=$xLength;
				double yLength=$yLength;
				double zLength=$zLength;


				/* Define dx and dt, and other simulation parameters
				*/
				std::cout<< \"Here2  \" << std::endl;
								double numSpacialPoints = $meshSize-1;
				double h=xLength/numSpacialPoints;
				double dtCell = $timeStepODE;
				double dtTissue =$timeStepPDE;
				double timeDuration=$timeDuration;
					
				// Number of output time steps, and size of output time step. Note that dtOut/dtTissue and dtOut/dtCell must be integers
				std::cout<< \"Here3  \" << std::endl;
				std::cout<< \"h = \" << h << std::endl;
				double numPrintTimeSteps=$numTimeSteps-1;
				double dtOut = timeDuration/numPrintTimeSteps;


				/* The {{{HeartConfig}}} class is used to set various parameters (see the main ChasteGuides page
				* for information on default parameter values. Parameters in this file can be re-set
				* with {{{HeartConfig}}} if the user wishes, and other parameters such as end time must be set
				* using {{{HeartConfig}}}. Let us begin by setting the end time (in ms), the mesh to use, and the
				* output directory and filename-prefix. 
				*/
				std::cout<< \"Here4  \" << std::endl;
				HeartConfig::Instance()->SetSimulationDuration(timeDuration); //ms
				TetrahedralMesh<3,3> mesh;
				mesh.ConstructRegularSlabMesh(h,xLength,yLength,zLength);
				HeartConfig::Instance()->SetOutputDirectory(\"$output_dir\");
				HeartConfig::Instance()->SetOutputFilenamePrefix(\"results\");
				HeartConfig::Instance()->SetVisualizerOutputPrecision($numDigits);
				//std::vector<std::string> output_variables;
				//output_variables.push_back(\"m\");
				//output_variables.push_back(\"h\");

				//HeartConfig::Instance()->SetOutputVariables(output_variables);
				
				
				
				//SimpleStimulus::Instance()->

				//for (TetrahedralMesh<3,3>::NodeIterator iter = mesh.GetNodeIteratorBegin(); iter != mesh.GetNodeIteratorEnd(); ++iter)
				//{
				//	if (($electrodeposition_x<=(iter->rGetLocation()[0])) && ((iter->rGetLocation()[0])<=$electrodeposition_x+$stimulusRange_x) && ($electrodeposition_y<=(iter->rGetLocation()[1]))&&((iter->rGetLocation()[1])<=$electrodeposition_y+$stimulusRange_y) && ($electrodeposition_z<=(iter->rGetLocation()[2]))&&((iter->rGetLocation()[2])<=$electrodeposition_z+$stimulusRange_z))
				//	{
						//std::ofstream outputFile("outStimDofs.txt",append);
				//		std::cout << iter->rGetLocation()[0] << \" \" << iter->rGetLocation()[1] << \" \" << iter->rGetLocation()[2] << std::endl;
				//	}
					//else
					//{
					//	std::cout << iter->rGetLocation()[0] << \" \" << iter->rGetLocation()[1] << \" \" << iter->rGetLocation()[2] << \"No  \" << std::endl;
					//	std::cout << \" No \" << std::endl;
					//}
				//}
				

				/*
				* It is possible to over-ride the default visualisation output (which is done during simulation
				* post-processing).
				*/
				HeartConfig::Instance()->SetVisualizeWithMeshalyzer(true);
				//HeartConfig::Instance()->SetVisualizeWithCmgui(true);
				//HeartConfig::Instance()->SetVisualizeWithVtk(true);

				/* To set the conductivity values
				*  in the principal fibre, sheet and normal directions do the following.
				* Note that {{{Create_c_vector}}} is just a helper method for creating a {{{c_vector<double,DIM>}}}
				* of the correct size (3, in this case). Make sure these methods are called before
				* {{{Initialise()}}}.
				*/
				std::cout<< \"Here5  \" << std::endl;
				//HeartConfig::Instance()->SetOutputVariables( $cellModelConstructor.rGetStateVariableNames() );
				HeartConfig::Instance()->SetIntracellularConductivities(Create_c_vector($sigma_ix, $sigma_iy, $sigma_iz));   // ms/cm
				HeartConfig::Instance()->SetExtracellularConductivities(Create_c_vector($sigma_ex, $sigma_ey, $sigma_ez));   // ms/cm
				
				/* This is how to reset the surface-area-to-volume ratio and the capacitance.
				* (Here, we are actually just resetting them to their default values). */
				HeartConfig::Instance()->SetSurfaceAreaToVolumeRatio($Chi); // 1/cm
				HeartConfig::Instance()->SetCapacitance($Cm); // uF/cm^2

				/* This is how to set the ode timestep (the timestep used to solve the cell models)
				* the pde timestep (the timestep used in solving the bidomain PDE), and the
				* printing timestep (how often the output is written to file). The defaults are
				* all 0.01, here we increase the printing timestep.
				*/
				HeartConfig::Instance()->SetOdePdeAndPrintingTimeSteps(dtCell, dtTissue, dtOut);

				std::cout<< \"Here6  \" << std::endl;

				// Use Godunov OS method
				//HeartConfig::Instance()->SetUseReactionDiffusionOperatorSplittingBidomainSolver();
				HeartConfig::Instance()->SetUseReactionDiffusionOperatorSplitting();
				//HeartConfig::Instance()->SetUseGodunovReactionDiffusionOperatorSplittingBidomainSolver();

	
				/* Next, we have to create a cell factory of the type we defined above. */
								PointStimulus3dCellFactory cell_factory;
				
								/* Now we create a problem class using (a pointer to) the cell factory. */
								BidomainProblem<3> bidomain_problem( &cell_factory );

				std::cout<< \"Here7  \" << std::endl;


				/* Now we call Solve() to run the simulation. The output will be written to
				* \`/tmp/$USER/testoutput/$filedirectory\` in HDF5 format.  The
				* output will also be converted to selected visualiser formats at the end of the simulation.
				* Note that if you want to view the progress of longer simulations
				* go to the the output directory and look at the file
				* {{{progress_status.txt}}}, which will say the percentage of the
				* simulation run. */

				std::cout<< \"Here8  \" << std::endl;				

					bidomain_problem.SetMesh(&mesh);

				std::cout<< \"Here9  \" << std::endl;

				
				bidomain_problem.Initialise();
				
				//std::cout<< \"IStim = \" << GetIntracellularAreaStimulus(time);

				std::cout<< \"Here10  \" << std::endl;

				bidomain_problem.Solve();
				//std::cout << GetStimulus(0.2) << std::endl;
				//for (int i=0; i<output_variables.size(); i++)
				//{
				//	std::cout << output_variables.at(i) << std::endl;
				//}
				//std::cout  << output_variables.size() << std::endl;
				

				std::cout<< \"Here 11 \" << std::endl;

				}
			};

			#endif /*TESTCHASTES1S2BIDOMAIN_HPP_*/


			" > $CHASTE_LOCATION/$FILE_LOCATION/$fileNameCplusplus

			##################################


		#Build and execute the C++ file
			# Add file to ContinuousTestPack.txt if it's not already there
			grep -q '$fileNameCplusplus' $CHASTE_LOCATION/$FILE_LOCATION/ContinuousTestPack.txt || echo "$fileNameCplusplus" >> $CHASTE_LOCATION/$FILE_LOCATION/ContinuousTestPack.txt

			cd $CHASTE_BUILD
			cmake -DChaste_NUM_CPUS_TEST=$numOfCore $CHASTE_LOCATION
		make $fileName
			ctest -V -R $fileName$  #>> $CHASTE_TEST_OUTPUT/$fileResults
    
	done
	done
	done
done 

